---
title: "Tidybiology +DS: Session 2 "
subtitle: "An Introduction to Biological Data Science in R"
author: "Matthew Hirschey, Ph.D."
date: "April 8-9, 2020"
output: 
  ioslides_presentation:
    widescreen: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
library(knitr)
library(here)
library(twitterwidget)
library(rlang)
knitr::opts_chunk$set(echo = FALSE, 
                      fig.align="center")
```

```{r load_data, message=FALSE, warning=FALSE, include=FALSE}
source(here::here("code", "healthcare.R")) #loads dataset-specific variables

#set.seed(42)
df_input <- data # df MUST contain at least one character and one numeric variable
df_numeric <- df_input %>% select_if(~is.numeric(.) & length(unique(.)) > 10) %>% select(-patient_id) # this is so that you avoid selecting variables that are actually factors
df_character <- df_input %>% select_if(~is.character(.)) 
df_numeric_select <- df_numeric[sample(1:ncol(df_numeric), 1)] # choose a random numeric column
df_numeric_filter <- df_numeric_select[sample(1:nrow(df_numeric), 1),] # choose a random number within that column
df_character_select <- df_character[sample(1:ncol(df_character), 1)] # choose a random character column
df_character_filter <- df_character_select[sample(1:nrow(df_character), 1),] # choose a random value within that column
```

# Basic ggplot2

## Basics of a ggplot code {.build}

Below is an example of the most basic form of the ggplot code

ggplot(data) +   
  geom(mapping=aes(x, y)) 

## Basics of a ggplot code {.build}
ggplot(data = df_input) +  
geom_point(mapping=aes(x = `r colnames(df_numeric)[1]`, y = `r colnames(df_numeric)[2]`))
```{r simple plot, echo = FALSE, warning = FALSE}
x <- sym(colnames(df_numeric)[1])
y <- sym(colnames(df_numeric)[2])

df_input %>% 
  ggplot(aes(!!x, !!y)) +
  geom_point() 
```

## Basics of a ggplot code {.build}
Take a moment to look back at the code you ran previously. You can see that in that code we assigned a dataset and the information we needed to map it to a scatterplot.

## Basics of a ggplot code {.build}
A note on ggplot style: while you can put the `+` at the beginning of the next line, it is generally put at the end of the previous line.

How does this chunk of code differ from the previous chunk?

ggplot(df_input) +    
geom_point(aes(x = `r colnames(df_numeric)[1]`, y = `r colnames(df_numeric)[2]`))

## Geoms {.build}
When plotting your data, it is often helpful to take a glimpse at the data you intend to plot to know what kinds of variables you will be working with
```{r glimpse again}
glimpse(df_input)
```

## Geoms {.build}
So now that you know your variable types, how do you know what geoms to use??
Use the following resources! 
  * https://rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf
  * https://www.data-to-viz.com/ 

Sometimes you will run into errors indicating more information is needed for a plot or that you do not have the correct variable types. For more in depth information on the geoms, I find the ggplot2 reference page more helpful than the built in help pages
  * https://ggplot2.tidyverse.org/reference/index.html

## Aesthetics {.build}
Everything up to this point gets you a basic graph- but what about colors, shapes and overall style? 

There are 5 basic aesthetics you can can change  
1. Color - changes the outline color of your datapoints  
2. Size    
3. Shape  
4. Alpha - changes the transparency of each point  
5. Fill- changes the fill color of your points  

## Global vs Local {.build}
In ggplot2, we have the options to set mappings globally or locally. Setting a mapping globally means to set those values in the original ggplot function.
Example: Earlier in class you made this graph:

ggplot(df_input) +    
  geom_jitter(aes(x=`r colnames(df_character)[1]`, y=log(`r colnames(df_numeric)[1]`)))+
  geom_boxplot(aes(x=`r colnames(df_character)[1]`, y=log(`r colnames(df_numeric)[1]`)))

## Global vs Local {.build}
```{r global v local, echo = FALSE, warning = FALSE}
x <- sym(colnames(df_character)[1])
y <- sym(colnames(df_numeric)[1])

df_input %>% 
  ggplot() +
  geom_jitter(aes(!!x, !!y)) +
  geom_boxplot(aes(!!x, !!y))
```

## Global vs Local {.build}
However, if we map our x and y values in the ggplot function we find that we generate the same graph  
ggplot(df_input, aes(x=`r colnames(df_character)[1]`, y=log(`r colnames(df_numeric)[1]`)) +
geom_jitter() +  
geom_boxplot()  
```{r global v local repeat, echo = FALSE, warning = FALSE}
x <- sym(colnames(df_character)[1])
y <- sym(colnames(df_numeric)[1])

df_input %>% 
  ggplot() +
  geom_jitter(aes(!!x, !!y)) +
  geom_boxplot(aes(!!x, !!y))
```

## Global vs Local {.build}
This is because when you set the aes mappings in the orignal ggplot function you are setting the aes **globally**.
This means all the functions afterwards will inherit that mapping. So in our Example this means that both the jitter and boxplot geoms know to graph `r colnames(df_character)[1]` by `r colnames(df_numeric)[1]`  

You can also set aes values **locally** within the geom function. Doing so will only change the values in that geom

## Global vs Local {.build}
ggplot(df_input, aes(x=`r colnames(df_character)[1]`, y=log(`r colnames(df_numeric)[1]`)) +  
  geom_jitter() +    
  geom_boxplot(aes(color = log(`r colnames(df_character)[1]`))   
```{r global v local colour, echo = FALSE, warning = FALSE}
x <- sym(colnames(df_character)[1])
y <- sym(colnames(df_numeric)[1])

df_input %>% 
  ggplot(aes(!!x, !!y)) +
  geom_jitter() +
  geom_boxplot(aes(colour = !!x))
```

## Global vs Local {.build}
Data can also be set locally or globally. For this example, let's filter our original data first using the `dplyr::filter` function

df_filter <- filter(df_input, `r colnames(df_numeric)[1]` > `r round(mean(df_numeric[[1]]))`)

## Global vs Local {.build}
Now, let's label only the points identified in our df_filter data by setting data locally in a new geom   
ggplot(df_input, aes(x=`r colnames(df_character)[1]`, y=log(`r colnames(df_numeric)[1]`)) +      
  geom_jitter() +        
  geom_boxplot(aes(color = log(`r colnames(df_character)[1]`)) +      
  geom_label(data=df_filter, aes(label=`r colnames(df_character)[2]`))

## Global vs Local {.build}
```{r global v local colour filter, echo = FALSE, warning = FALSE}
x <- sym(colnames(df_character)[1])
z <- sym(colnames(df_character)[2])
y <- sym(colnames(df_numeric)[1])
df_filter <- filter(df_input, df_numeric[1] > round(mean(df_numeric[[1]])))

df_input %>% 
  ggplot(aes(!!x, !!y)) +
  geom_jitter() +
  geom_boxplot(aes(colour = !!x)) +
  geom_label(data=df_filter, aes(label=!!z)) 
```

## Global vs Local {.build}
You notice we have to indicate the new dataset, but because it has the same x and y values, we did not need to set those mappings

## Labels and Legends {.build}
You've likely noticed that up until this point ggplot has labeled axes, but not necessarily in a very pleasing manner.  
We can change these settings in our graph using the labs() function.   

Let's start by simply changing the x-axis label
ggplot(df_input, aes(x=`r colnames(df_character)[1]`, y=log(`r colnames(df_numeric)[1]`)) +    
  geom_jitter() +      
  geom_boxplot(aes(color = log(`r colnames(df_character)[1]`)) +    
  geom_label(data=df_filter, aes(label=`r colnames(df_character)[2]`)) +  
  labs(x = "`r str_to_title(colnames(df_character)[1])`")

## Labels and Legends {.build}
```{r global v local colour filter label, echo = FALSE, warning = FALSE}
x <- sym(colnames(df_character)[1])
z <- sym(colnames(df_character)[2])
y <- sym(colnames(df_numeric)[1])
df_filter <- filter(df_input, df_numeric[1] > round(mean(df_numeric[[1]])))

df_input %>% 
  ggplot(aes(!!x, !!y)) +
  geom_jitter() +
  geom_boxplot(aes(colour = !!x)) +
  geom_label(data=df_filter, aes(label=!!z)) +
  labs(x = str_to_title(sym(colnames(df_character)[1])))
```

## Labels and Legends {.build}
Now, seeing as we have a pretty explanatory legend, we could try to get rid of it. This becomes especially useful when ggplot gives you legends that don't make sense to show

ggplot(df_input, aes(x=`r colnames(df_character)[1]`, y=log(`r colnames(df_numeric)[1]`)) +    
  geom_jitter() +      
  geom_boxplot(aes(color = log(`r colnames(df_character)[1]`)) +    
  geom_label(data=df_filter, aes(label=`r colnames(df_character)[2]`)) +  
  labs(x = "`r str_to_title(colnames(df_character)[1])`") +  
  guides(color = "none")

## Labels and Legends {.build}
```{r global v local colour filter label guides, echo = FALSE, warning = FALSE}
x <- sym(colnames(df_character)[1])
z <- sym(colnames(df_character)[2])
y <- sym(colnames(df_numeric)[1])
df_filter <- filter(df_input, df_numeric[1] > round(mean(df_numeric[[1]])))

df_input %>% 
  ggplot(aes(!!x, !!y)) +
  geom_jitter() +
  geom_boxplot(aes(colour = !!x)) +
  geom_label(data=df_filter, aes(label=!!z)) +
  labs(x = str_to_title(sym(colnames(df_character)[1]))) +
  guides(color = "none")
```

## Faceting {.build}
Faceting allows you to create multiple graphs side by side in one panel. Especially useful when you want to see the data together, but not on top of each other

For example

ggplot(df_input) +  
geom_point(aes(x=`r colnames(df_character)[1]`, y=log(`r colnames(df_numeric)[1]`)) +  
facet_grid(cols = vars(`r colnames(df_character)[2]`))

## Faceting {.build}
```{r facetting, echo = FALSE, warning = FALSE}
x <- sym(colnames(df_character)[1])
z <- sym(colnames(df_character)[2])
y <- sym(colnames(df_numeric)[1])

df_input %>% 
  ggplot(aes(!!x, !!y)) +
  geom_point() +
  facet_grid(cols = vars(!!z))
```

## Coordinate flipping {.build}
Coordinate flipping is an especially useful tool when your x-axis includes characters that overlap. Coordinate flipping keeps your mappings and aes the same, but flips coordinates so that your x-axis displays on the y-axis instead. This allows any names included in the x-axis titles to be read more easily  

ggplot(df_input) +  
geom_jitter(aes(x=`r colnames(df_character)[1]`, y=log(`r colnames(df_numeric)[1]`)) +  
coord_flip()

## Coordinate flipping {.build}
```{r coord flipping, echo = FALSE, warning = FALSE}
x <- sym(colnames(df_character)[1])
y <- sym(colnames(df_numeric)[1])

df_input %>% 
  ggplot(aes(!!x, !!y)) +
  geom_jitter() +
  coord_flip()
```

## Themes {.build}
You can change almost everything you see on your chart, but a lot of the things you may look to change are part of the "theme"  

Here we are going to change some features about our title text

ggplot(df_input, aes(x=`r colnames(df_character)[1]`, y=log(`r colnames(df_numeric)[1]`)) +    
  geom_jitter() +      
  geom_boxplot(aes(color = log(`r colnames(df_character)[1]`)) +  
  labs(title = "My first plot") +  
  theme(
     plot.title = element_text(face = "bold", size = 12)
    ) 

## Themes {.build}
```{r themes, echo = FALSE, warning = FALSE}
x <- sym(colnames(df_character)[1])
z <- sym(colnames(df_character)[2])
y <- sym(colnames(df_numeric)[1])
df_filter <- filter(df_input, df_numeric[1] > round(mean(df_numeric[[1]])))

df_input %>% 
  ggplot(aes(!!x, !!y)) +
  geom_jitter() +
  geom_boxplot(aes(colour = !!x)) +
  labs(title = "My first plot") +
  theme(
     plot.title = element_text(face = "bold", size = 12)
    ) 
```

## Themes {.build}
Next, let's change the aesthetics of our legend box  

ggplot(df_input, aes(x=`r colnames(df_character)[1]`, y=log(`r colnames(df_numeric)[1]`)) +    
  geom_jitter() +      
  geom_boxplot(aes(color = log(`r colnames(df_character)[1]`)) +  
  labs(title = "My first plot") +  
  theme(
     plot.title = element_text(face = "bold", size = 12),
     legend.background = element_rect(fill="gray", colour="black")
    ) 

## Themes {.build}
```{r themes two, echo = FALSE, warning = FALSE}
x <- sym(colnames(df_character)[1])
z <- sym(colnames(df_character)[2])
y <- sym(colnames(df_numeric)[1])
df_filter <- filter(df_input, df_numeric[1] > round(mean(df_numeric[[1]])))

df_input %>% 
  ggplot(aes(!!x, !!y)) +
  geom_jitter() +
  geom_boxplot(aes(colour = !!x)) +
  labs(title = "My first plot") +
  theme(
     plot.title = element_text(face = "bold", size = 12),
     legend.background = element_rect(fill="gray", colour="black")
    ) 
```

## Themes {.build}
Finally, let's change the legend postion  

ggplot(df_input, aes(x=`r colnames(df_character)[1]`, y=log(`r colnames(df_numeric)[1]`)) +    
  geom_jitter() +      
  geom_boxplot(aes(color = log(`r colnames(df_character)[1]`)) +  
  labs(title = "My first plot") +  
  theme(
     plot.title = element_text(face = "bold", size = 12),
     legend.background = element_rect(fill="gray", colour="black"),
     legend.position = "bottom"
    ) 

## Themes {.build}
```{r themes three, echo = FALSE, warning = FALSE}
x <- sym(colnames(df_character)[1])
z <- sym(colnames(df_character)[2])
y <- sym(colnames(df_numeric)[1])
df_filter <- filter(df_input, df_numeric[1] > round(mean(df_numeric[[1]])))

df_input %>% 
  ggplot(aes(!!x, !!y)) +
  geom_jitter() +
  geom_boxplot(aes(colour = !!x)) +
  labs(title = "My first plot") +
  theme(
     plot.title = element_text(face = "bold", size = 12),
     legend.background = element_rect(fill="gray", colour="black"),
     legend.position = "bottom"
    ) 
```

## Themes {.build}
Pre-set themes also exist as an easy way to change the entire theme of your graph quickly. They can also be combined with custom theme settings  

ggplot(df_input, aes(x=`r colnames(df_character)[1]`, y=log(`r colnames(df_numeric)[1]`)) +    
  geom_jitter() +      
  geom_boxplot(aes(color = log(`r colnames(df_character)[1]`)) +  
  labs(title = "My first plot") +  
  theme_bw()

## Themes {.build}
```{r themes four, echo = FALSE, warning = FALSE}
x <- sym(colnames(df_character)[1])
z <- sym(colnames(df_character)[2])
y <- sym(colnames(df_numeric)[1])
df_filter <- filter(df_input, df_numeric[1] > round(mean(df_numeric[[1]])))

df_input %>% 
  ggplot(aes(!!x, !!y)) +
  geom_jitter() +
  geom_boxplot(aes(colour = !!x)) +
  labs(title = "My first plot") +
  theme_bw()
```

## Saving plots using ggsave {.build}

If you make a plot there are a few ways to save it, though the simplest is to use ggsave  

ggsave("ggsaveexample.png")  

You can change the type of file you save or even the size in inches.  
example:  

ggsave("ggsaveexample.pdf", width = 6, height = 6)  

## Saving plots using ggsave {.build}
Where does it save??

getwd()
```{r getwd}
getwd()
```
